[{"title":"你想 pick 哪款嵌入式 Markdown 编辑器?","url":"http://example.com/2020/09/01/2020-09-01-pick-embeddable-markdown-editor/","content":"<p>首先先声明下，我们今天要讲的并非客户端软件，而是“嵌入式”的 Markdown。</p>\n<p>什么是嵌入式？嵌入式是计算机工程中的一个专业术语，即嵌入式系统。</p>\n<blockquote>\n<p>嵌入式系统用于控制、监视或者辅助操作机器和设备的装置，是一种专用的计算机系统。</p>\n</blockquote>\n<p>本文中提到的嵌入式，其实更偏向于这种解释：一个可插拔的组件。</p>\n<p>插上它，某个功能就会实现。拔掉，又不会影响系统运行。</p>\n<p>Markdown是一种轻量级标记语言，易读易写，对图片、图标、数学式都有支持。可用于十几种编程语言，目前许多平台和框架都支持Markdown，主要应用在各个笔记和博客平台。</p>\n<blockquote>\n<p><strong>Markdown的时间轴</strong></p>\n<p>它诞生于2004年</p>\n<p>2014年9月，被更名为 <a href=\"https://commonmark.org/\">CommonMark</a></p>\n<p>2012年，实施标准化</p>\n<p>2017年，Github发布了基于CommonMark的<a href=\"https://github.github.com/gfm/\">Github Flavored Markdown（GFM）</a>的正式规范。</p>\n<p>2018年，发布 CommonMark 规范和测试包</p>\n<p>…</p>\n</blockquote>\n<p>此时，你可能会cue到富文本编辑器，它拥有着类 Word 软件般的用户体验————所见即所得，但其致命的缺点是容易造成 XSS 漏洞。</p>\n<p>跑偏了，今天的主角不是它『富文本』，而是它『Markdown』👈</p>\n<p>接下来推荐几款小编接触到的可嵌入的Markdown编辑器。</p>\n<h2 id=\"tui-editor\"><a href=\"#tui-editor\" class=\"headerlink\" title=\"tui.editor\"></a>tui.editor</h2><p>第一款是由韩国 nhn 官方维护 <code>tui.editor</code>。</p>\n<p><a href=\"https://github.com/nhn/tui.editor\">TOAST UI Editor</a> 是一款的基于 GFM(GitHub Flavored Markdown)的编辑器，拥有两个模式 Markdown 和 WYSIWYG（所见即所得），可在写作过程中任意切换。 用户体验也是相当的舒适，对于偏好富文本编辑器的用户来说，可谓是顺滑切换。</p>\n<p>如果你读过 tui.editor 的文档，是否也和我一样觉得真香呢。</p>\n<p>👉它的特性：</p>\n<ul>\n<li>提供了3种框架组件<ul>\n<li><a href=\"https://github.com/nhn/tui.editor/tree/master/apps/jquery-editor\">@toast-ui/jquery-editor</a></li>\n<li><a href=\"https://github.com/nhn/tui.editor/tree/master/apps/react-editor\">@toast-ui/react-editor</a></li>\n<li><a href=\"https://github.com/nhn/tui.editor/tree/master/apps/vue-editor\">@toast-ui/vue-editor</a></li>\n</ul>\n</li>\n<li>提供了强大的 Markdown 语法的扩展插件<ul>\n<li><a href=\"https://github.com/nhn/tui.editor/tree/master/plugins/chart\">chart</a> 图表</li>\n<li><a href=\"https://github.com/nhn/tui.editor/tree/master/plugins/code-syntax-highlight\">code-syntax-highlight</a> 代码块区域高亮</li>\n<li><a href=\"https://github.com/nhn/tui.editor/tree/master/plugins/color-syntax\">color-syntax</a> 文本颜色选择器</li>\n<li><a href=\"https://github.com/nhn/tui.editor/tree/master/plugins/table-merged-cell\">table-merged-cell</a> 表格合并单元格</li>\n<li><a href=\"https://github.com/nhn/tui.editor/tree/master/plugins/uml\">uml</a> UML（ 统一建模语言）图</li>\n</ul>\n</li>\n<li>提供了丰富的 <a href=\"https://nhn.github.io/tui.editor/latest/\">API</a>，方便使用者开发自己的扩展</li>\n<li>在浏览器支持方面也是很喜人，支持IE 10+</li>\n<li>支持Viewer模式（只读模式），用于编辑器内容的最终呈现（多用于详情页中）</li>\n<li>支持<a href=\"https://github.com/nhn/tui.editor/blob/master/apps/editor/docs/i18n.md#supported-languages\">国际化</a></li>\n</ul>\n<p>介绍到这，你是否也心动了。喜欢它，就Pick它吧~</p>\n<p><a href=\"https://nhn.github.io/tui.editor/latest/tutorial-example01-editor-basic\">在线demo</a></p>\n<h2 id=\"SimpleMDE\"><a href=\"#SimpleMDE\" class=\"headerlink\" title=\"SimpleMDE\"></a>SimpleMDE</h2><p><a href=\"https://github.com/sparksuite/simplemde-markdown-editor\">SimpleMDE</a> 是一个可嵌入的JavaScript Markdown编辑器，除了基础的字体加粗、倾斜，插入图片、链接等功能外，还支持自动保存和拼写检查。</p>\n<p>小编研究了下，这个自动保存是基于 localStorage 存储，如果你用到这个功能了，切记尽量不存储base64格式的图片，不然会造成内存溢出。你懂得『毕竟localstorage只支持5M大小』。</p>\n<p>在预防XSS攻击方面，作者并未对此做处理。从github的代码提交时间来看，目前已不再维护，深表遗憾。如果你有想法，可以fork 它，自己维护，小编表示很赞同呢。</p>\n<p>这款编辑器虽未像 tui.editor一样，提供了 “所见即所得”模式，但它有贴心地提供了 <a href=\"https://simplemde.com/markdown-guide\">Markdown使用指南</a>，不管你的项目是基于 Vue 还是 React，你都可以Pick它，还是很nice的~</p>\n<p><a href=\"https://simplemde.com/\">在线demo</a></p>\n<hr>\n<p>以上两款，不管在哪个框架中都能使用。接下来介绍三款分别基jQuery、Vue和React的Markdown Editor组件</p>\n<hr>\n<h2 id=\"Editor-md\"><a href=\"#Editor-md\" class=\"headerlink\" title=\"Editor.md\"></a>Editor.md</h2><p><a href=\"https://github.com/pandao/editor.md\">Editor.md</a> 是一款国产可嵌入的开源 Markdown 在线编辑器组件。基于 CodeMirror、jQuery 和 Marked 构建。同时支持通用 Markdown / CommonMark 和 GFM (GitHub Flavored Markdown) 风格的语法，特性相当丰富。在这5款编辑器中，目前 Star 数也是仅次于 tui.editor。</p>\n<p>它的特性也是很丰富，总有一个满足你的要求😍。</p>\n<p>👉它的特性：</p>\n<ul>\n<li>支持实时预览、图片（跨域）上传、预格式文本/代码/表格插入、代码折叠、搜索替换、只读模式、自定义样式主题和多语言语法高亮等功能；</li>\n<li>支持 ToC 目录（Table of Contents）、Emoji 表情、Task lists、@链接等 Markdown 扩展语法；</li>\n<li>支持 TeX 科学公式（基于 KaTeX）、流程图 Flowchart 和 时序图 Sequence Diagram;</li>\n<li>支持识别和解析 HTML 标签，并且支持自定义过滤标签解析，具有可靠的安全性和几乎无限的扩展性；</li>\n<li>支持 AMD / CMD 模块化加载（支持 Require.js &amp; Sea.js），并且支持自定义扩展插件；</li>\n<li>兼容主流的浏览器（IE8+）和 Zepto.js，且支持 iPad 等平板设备；</li>\n<li>支持自定义主题样式；</li>\n</ul>\n<p>虽说这款编辑器已经对基础的XSS攻击做了处理，但还是存在安全隐患，由于它目前处于维护态，可能维护者已经在修BUG的路上了。如果你有解决办法，可以给它提 <a href=\"https://github.com/pandao/editor.md/compare\">PR</a> 👈。</p>\n<p>如果你对我所说的安全隐患有兴趣，可以试运行以下代码。</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">img</span> <span class=\"attr\">src</span>=<span class=\"string\">&quot;https://pandao.github.io/editor.md/images/logos/editormd-logo-180x180.png&quot;</span> <span class=\"attr\">onload</span>=<span class=\"string\">&quot;javascript:alert(1)&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p><a href=\"http://editor.md.ipandao.com/\">在线demo</a></p>\n<h2 id=\"uiw-react-md-editor\"><a href=\"#uiw-react-md-editor\" class=\"headerlink\" title=\"@uiw/react-md-editor\"></a>@uiw/react-md-editor</h2><p><a href=\"https://github.com/uiwjs/react-md-editor\">@uiw/react-md-editor</a> 是一个由 React 和 TypeScript 实现的带有预览的 Markdown 编辑器。目前由 uiw 团队维护。</p>\n<blockquote>\n<p>uiw 是基于 React 16+ 的 UI 组件库。</p>\n</blockquote>\n<p>👉它的特性：</p>\n<ul>\n<li>三种模式任意切换：编辑、预览、编辑 + 实时预览</li>\n<li>支持Viewer模式（只读模式），用于编辑器内容的最终呈现。最常见于文章详情页的展示</li>\n<li>支持 KaTeX 科学公式预览</li>\n<li>包体积很小，才 439 kB</li>\n</ul>\n<p>因为它是一个 React 组件，所以用法也很简单。直接引入，加上配置就哦了。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> React <span class=\"keyword\">from</span> <span class=\"string\">&quot;react&quot;</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> ReactDOM <span class=\"keyword\">from</span> <span class=\"string\">&quot;react-dom&quot;</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> MDEditor <span class=\"keyword\">from</span> <span class=\"string\">&#x27;@uiw/react-md-editor&#x27;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">App</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> [value, setValue] = React.useState(<span class=\"string\">&quot;**Hello world!!!**&quot;</span>);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> (</span><br><span class=\"line\">    &lt;div className=<span class=\"string\">&quot;container&quot;</span>&gt;</span><br><span class=\"line\">      &lt;MDEditor</span><br><span class=\"line\">        value=&#123;value&#125;</span><br><span class=\"line\">        onChange=&#123;setValue&#125;</span><br><span class=\"line\">      /&gt;</span><br><span class=\"line\">      &lt;MDEditor.Markdown source=&#123;value&#125; /&gt;</span><br><span class=\"line\">    &lt;/div&gt;</span><br><span class=\"line\">  );</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><a href=\"https://uiwjs.github.io/react-md-editor/\">在线demo</a></p>\n<h2 id=\"mavon-editor\"><a href=\"#mavon-editor\" class=\"headerlink\" title=\"mavon-editor\"></a>mavon-editor</h2><p><a href=\"https://github.com/hinesboy/mavonEditor\">mavonEditor</a>是一个基于 Vue 的 Markdown 编辑器。目前它是由个人维护，实现了部分国际化，支持8种语言。看过之前几款后，再来看它，有种眼前一亮的感觉，因为它的特性很新颖。可以在vue中使用，也可以在 nuxt.js 中使用。</p>\n<p>👉它的特性：</p>\n<ul>\n<li>支持上下角标</li>\n<li>支持文字高亮（标记笔）</li>\n<li>支持下划线</li>\n<li>支持布局：居左、居中、居右</li>\n<li>支持 KATEX公式 预览</li>\n<li>支持标题导航</li>\n<li>支持国际化</li>\n<li>支持快捷键设置</li>\n<li>支持撤回、恢复、清空等等</li>\n</ul>\n<p><a href=\"http://106.15.232.22/\">在线demo</a></p>\n<h2 id=\"一览\"><a href=\"#一览\" class=\"headerlink\" title=\"一览\"></a>一览</h2><table>\n<thead>\n<tr>\n<th>editor</th>\n<th>关注数</th>\n<th>更新情况</th>\n<th>存在xss风险级别</th>\n<th>框架支持情况</th>\n<th>npm包</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>tui.editor</td>\n<td>11k+</td>\n<td>一个月前</td>\n<td>低</td>\n<td>支持jQuery, Vue, React</td>\n<td><a href=\"https://www.npmjs.com/package/@toast-ui/editor\">@toast-ui/editor</a></td>\n</tr>\n<tr>\n<td>SimpleMDE</td>\n<td>8k</td>\n<td>4年前</td>\n<td>高</td>\n<td>支持jQuery, Vue, React</td>\n<td><a href=\"https://www.npmjs.com/package/simplemde\">simplemde</a></td>\n</tr>\n<tr>\n<td>editor.md</td>\n<td>10k+</td>\n<td>16个月前</td>\n<td>较低</td>\n<td>支持jQuery</td>\n<td><a href=\"https://www.npmjs.com/package/editor.md\">editor.md</a></td>\n</tr>\n<tr>\n<td>@uiw/react-md-editor</td>\n<td>134</td>\n<td>几天前</td>\n<td>较低</td>\n<td>支持React</td>\n<td><a href=\"https://www.npmjs.com/package/@uiw/react-md-editor\">@uiw/react-md-editor</a></td>\n</tr>\n<tr>\n<td>mavonEditor</td>\n<td>4.2k</td>\n<td>4个月前</td>\n<td>较低</td>\n<td>支持Vue</td>\n<td><a href=\"https://www.npmjs.com/package/mavon-editor\">mavon-editor</a></td>\n</tr>\n</tbody></table>\n<p>以上是这几个嵌入式 Markdown 编辑器的一览。除了小编介绍的这几款，肯定还有很多其他优秀的 Markdown 编辑器，如果你知道也可推荐给我。</p>\n<p>推荐了这么多款，总有一款适合你，快点来Pick吧！！！</p>\n","categories":["前端"],"tags":["Markdown"]},{"title":"读“在框架设计中寻求平衡”","url":"http://example.com/2019/12/30/2019-12-30-seeking-the-balance-in-framework-design/","content":"<p>今年 JSConf.Asia 会议上，Vue.js 的作者 @尤雨溪 在关于 前端框架设计取舍 上作了分享。 分享主要从两个部分展开介绍： 职责范围（Scope）和 渲染机制（Render Mechanism）。</p>\n<h4 id=\"职责范围\"><a href=\"#职责范围\" class=\"headerlink\" title=\"职责范围\"></a>职责范围</h4><p>小的职责范围具有很好的灵活度，但关于构建抽象上要求开发者有自主学习能力。相反，大的职责范围致力于提供抽象概念，倘若抽象不适用，想改变时，却缺乏灵活度。</p>\n<p>Vue 在职责范围这个问题的处理方式上，采取了渐进式。</p>\n<p><img src=\"https://p1.ssl.qhimg.com/t01fe27088aa20d3ded.png\"></p>\n<p>通过渐进的方式来选择特性，让更多的人专注于开发，而不是学习一堆在当前开发中可能不需要的概念。对于当前一些问题，开发者仍然能通过文档来获取一些解决方案。</p>\n<p>这种渐进式一来让 Vue 也存在着大职责范围中的统一维护面问题；二来 Vue 生态也无法像小职责范围那样的多样化。</p>\n<h4 id=\"渲染机制\"><a href=\"#渲染机制\" class=\"headerlink\" title=\"渲染机制\"></a>渲染机制</h4><p>JSX 具有完整的 JavaScript 表现力，但由于渲染函数的动态特性使其难以优化。模板的约束允许编译器对你的意图作做预判，从而给它更多的空间执行优化；但因受限于模板语法，从而失去了 JavaScript 表达能力。</p>\n<p>单纯取舍不能解决问题，Vue 在渲染机制方面选择了 VDOM 结合模板编译，在模板编译上入手优化，引入了SVELTE，只对动态节点作 VDOM Diff 算法，从而提高了运行速度。</p>\n<p><img src=\"https://p1.ssl.qhimg.com/t01352166f663a62c22.png\" alt=\"svelte-logo-horizontal.svg\"></p>\n<p>接下来看看 SVELTE 是怎么处理的。</p>\n<p>场景1：只有一个动态节点</p>\n<p><img src=\"https://p3.ssl.qhimg.com/t01712c2274c39bc718.png\" alt=\"image\"></p>\n<p>当模板中只有一个动态节点时，整个节点结构是静态的、不会改变，我们只需直接更新 message 字符串这一个动态节点。</p>\n<p>场景2：存在结构指令</p>\n<p><img src=\"https://p1.ssl.qhimg.com/t01514e25d142756025.png\" alt=\"v-if Demo\"></p>\n<p>若存在结构指令 <code>v-if</code>，此时这个节点可能存在或可能不存在。处理办法是进行拆分，以 <code>v-if</code> 为界拆分成两个嵌套块。 </p>\n<ul>\n<li><code>v-if</code> 外部：是一个静态节点结构，只有 <code>v-if</code> 这一个动态节点</li>\n<li><code>v-if</code> 内部：也是一个静态节点结构，只有 <code>&#123;&#123; message &#125;&#125;</code> 一个动态节点</li>\n</ul>\n<p>唯一要处理的就是将每个块内的动态节点数组扁平化。</p>\n<blockquote>\n<p>数组扁平化是指将一个多维数组变为一维数组</p>\n</blockquote>\n<p><img src=\"https://p5.ssl.qhimg.com/t01df369a48ee8b05df.png\" alt=\"v-for Demo\"></p>\n<p>又或者存在的是结构指令 <code>v-for</code>，处理方式也是一样，将代码拆分成嵌套块…</p>\n<p><img src=\"https://p5.ssl.qhimg.com/t01a85190317eae945e.png\" alt=\"more v-if, v-for Demo\"></p>\n<p>若模板中存在多个 <code>v-if</code>、<code>v-for</code>，亦是如此。以结构指令为界，将模板拆分成嵌套块。每个块内的节点结构是静态的，动态节点维护在一个单一扁平化数组中。</p>\n<p><img src=\"https://p1.ssl.qhimg.com/t015cf5539238c56211.png\" alt=\"Block Tree\"></p>\n<p><img src=\"https://p1.ssl.qhimg.com/t01dc325e2cba4ce2e2.png\" alt=\"Block Tree Demo\"></p>\n<p>假设这个区块树存在上图的节点，那么得出的扁平化数组（结构指令 v-if, v-for 等本身也可以看出一个节点）为：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">B5: [node5, node6, node7]</span><br><span class=\"line\">B4: [node1, node2, node3, node4]</span><br><span class=\"line\">B3: [B5]</span><br><span class=\"line\">B2: [B4]</span><br><span class=\"line\">B1: [B2, B3]</span><br></pre></td></tr></table></figure>\n<p>如此一来，对于同一模板的Diff， vue2.x 和 vue3.x 在做法上就存在比较大的差异。vue2.x 会做一个完整的 Diff 操作，而 vue3.x 是比较一个单一扁平化数组中的文本是否发生变化。有实验表明，vue3.0 中使用的新的编译策略的速度比 vue2.x 快了6倍多。虽说是个实验数据，但或多或少，vue3 都是更快。</p>\n<p><img src=\"https://p1.ssl.qhimg.com/t015efdcb0ccb5fb4a3.png\" alt=\"实验数据\"></p>\n<h4 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h4><p>最后，我们回到本次分享中的话题。通过 @尤雨溪 的分享，我们能感受到他在框架设计中是如何寻求平衡的，这对我们今后的框架设计存在着许多借鉴意义。</p>\n<p>如何获取一个最佳平衡点，我们都曾有过努力寻找最佳的方式来解决问题的经历，我想这就是一个寻求最佳平衡点的过程。这个最佳方式不仅能解决现有问题，并且与后期的发展也一致，在我看来，这应该就是最佳平衡点。</p>\n","categories":["前端"],"tags":["框架设计"]},{"title":"Vue 和 React 的状态逻辑复用方案","url":"http://example.com/2019/01/16/2019-01-16-vue-and-react-multiplex/","content":"<h1 id=\"Vue-五种逻辑复用方案\"><a href=\"#Vue-五种逻辑复用方案\" class=\"headerlink\" title=\"Vue 五种逻辑复用方案\"></a>Vue 五种逻辑复用方案</h1><p>目前<code>Vue</code>实现代码逻辑复用主要5个途径： <code>Vuex</code>, <code>Mixins</code>(混入,  <code>Vue</code>推荐), <code>Hooks</code>, <code>HOC</code>(高阶组件, <code>React</code>推荐), 函数式组件</p>\n<h2 id=\"Vuex\"><a href=\"#Vuex\" class=\"headerlink\" title=\"Vuex\"></a>Vuex</h2><p>它采用集中式存储管理应用的所有组件的状态。对大型项目来说是个很好的状态管理模式，但存在对于引入太多抽象, 导致开发时总在不同的文件之间切换, 造成组件重用更困难等问题。</p>\n<h2 id=\"Mixins\"><a href=\"#Mixins\" class=\"headerlink\" title=\"Mixins\"></a>Mixins</h2><p>混合对象可以包含任意组件选项。以组件使用混合对象时，所有混合对象的选项将被混入该组件本身的选项。</p>\n<ul>\n<li>同名钩子函数将混合为一个数组，都将被调用，混合对象的钩子将在组件自身钩子之前调用</li>\n<li>当混合值为对象的选项，例如 methods 和 components 等将被混合为同一个对象。两个对象键名冲突时取组件对象的键值对。</li>\n<li>请慎重使用全局注册混合对象，一旦使用，将会影响所有之后创建的Vue实例。</li>\n</ul>\n<blockquote>\n<p>小剧场：起初<code>React</code>也是通过<code>mixins</code>实现代码复用，但后来React为了避免开发者在组件中总是要写一段相同的代码，一步步脱离<code>mixins</code>，他们认为<code>mixins</code>在<code>React</code>生态系统中不是一种好的模式。</p>\n</blockquote>\n<h2 id=\"Hooks\"><a href=\"#Hooks\" class=\"headerlink\" title=\"Hooks\"></a>Hooks</h2><p>Hooks遵循函数式编程的理念。是为了从组件中提取现有状态逻辑, 以便可以独立测试并重用。Hooks允许开发者在不更改组件层次结构的情况下重用有状态逻辑, 这样可以轻松地在许多组件之间或社区共享Hooks。</p>\n<p>现状：<a href=\"https://reactjs.org/docs/hooks-intro.html\">React-hooks</a>比较成熟, vue也有一个<a href=\"https://github.com/yyx990803/vue-hooks\">vue-hooks</a>, 但只是处于实验阶段。关于vue-hooks如何使用，尤大大在GitHub上也给出了相关示例，可以参考学习。</p>\n<blockquote>\n<p>推荐文章<br><a href=\"https://juejin.im/entry/5bda51576fb9a022824c0d27\">在 React 和 Vue 中尝鲜 Hooks</a></p>\n</blockquote>\n<h2 id=\"HOC\"><a href=\"#HOC\" class=\"headerlink\" title=\"HOC\"></a>HOC</h2><p>组件工厂，接受原始组件作为参数，添加完功能与业务后，返回新的组件。 React 在代码中实现复用的主要方式就是使用高阶函数。</p>\n<p><strong>现状</strong>：在React实现组件其实就是在写函数, 函数拥有的功能组件都有，故实现高阶组件也是比较简单。而vue更像是一个高度封装的函数, 缺少了一定灵活性, 写高阶组件也比较复杂，关于这块Vue官网也是简单的介绍，笔者也是搜罗阅读了一些文章，写了个简单的demo, 仅供参考。<a href=\"https://codesandbox.io/s/5xp39rx4kn\">Live Demo</a></p>\n <figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Wrapper.js</span></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Wrapper</span>(<span class=\"params\">WrappedComponent</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">    props: &#123;</span><br><span class=\"line\">      list: &#123;</span><br><span class=\"line\">        type: <span class=\"built_in\">Array</span>,</span><br><span class=\"line\">        <span class=\"keyword\">default</span>: <span class=\"function\">() =&gt;</span> []</span><br><span class=\"line\">      &#125;,</span><br><span class=\"line\">      title: <span class=\"built_in\">String</span></span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    <span class=\"function\"><span class=\"title\">render</span>(<span class=\"params\">h</span>)</span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> h(<span class=\"string\">&quot;div&quot;</span>, [</span><br><span class=\"line\">        h(<span class=\"string\">&quot;h3&quot;</span>, &#123;&#125;, <span class=\"built_in\">this</span>.title),</span><br><span class=\"line\">        h(</span><br><span class=\"line\">          <span class=\"string\">&quot;div&quot;</span>,</span><br><span class=\"line\">          &#123;</span><br><span class=\"line\">            class: &quot;flex-row main-align-space-around&quot;</span><br><span class=\"line\">          &#125;,</span><br><span class=\"line\">          <span class=\"built_in\">this</span>.list.map(<span class=\"function\"><span class=\"params\">item</span> =&gt;</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> h(WrappedComponent, &#123; <span class=\"attr\">props</span>: item &#125;);</span><br><span class=\"line\">          &#125;)</span><br><span class=\"line\">        )</span><br><span class=\"line\">      ]);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">&lt;!-- app.vue --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">template</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;app&quot;</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">anime-list</span> <span class=\"attr\">title</span>=<span class=\"string\">&quot;今日漫画&quot;</span> <span class=\"attr\">:list</span>=<span class=\"string\">&quot;animeList&quot;</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">anime-list</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">book-list</span> <span class=\"attr\">title</span>=<span class=\"string\">&quot;今日推荐书籍&quot;</span> <span class=\"attr\">:list</span>=<span class=\"string\">&quot;bookList&quot;</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">book-list</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">template</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span>&gt;</span></span><br><span class=\"line\"><span class=\"javascript\"><span class=\"keyword\">import</span> Item <span class=\"keyword\">from</span> <span class=\"string\">&quot;./components/Item&quot;</span>;</span></span><br><span class=\"line\"><span class=\"javascript\"><span class=\"keyword\">import</span> Wrapper <span class=\"keyword\">from</span> <span class=\"string\">&quot;./components/Wrapper&quot;</span>;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"javascript\"><span class=\"keyword\">const</span> AnimeList = Wrapper(Item);</span></span><br><span class=\"line\"><span class=\"javascript\"><span class=\"keyword\">const</span> BookList = Wrapper(Item);</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"javascript\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> &#123;</span></span><br><span class=\"line\"><span class=\"javascript\">  name: <span class=\"string\">&quot;App&quot;</span>,</span></span><br><span class=\"line\">  components: &#123;</span><br><span class=\"line\">    AnimeList,</span><br><span class=\"line\">    BookList</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\"><span class=\"javascript\">  <span class=\"function\"><span class=\"title\">data</span>(<span class=\"params\"></span>)</span> &#123;</span></span><br><span class=\"line\"><span class=\"javascript\">    <span class=\"keyword\">return</span> &#123;</span></span><br><span class=\"line\">      animeList: [],</span><br><span class=\"line\">      bookList: []</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://user-images.githubusercontent.com/17926741/98777650-19815780-242c-11eb-8a35-ddb3399cb1c5.png\" alt=\"高阶组件效果图\"></p>\n<blockquote>\n<p>推荐文章<br><a href=\"http://hcysun.me/2018/01/05/%E6%8E%A2%E7%B4%A2Vue%E9%AB%98%E9%98%B6%E7%BB%84%E4%BB%B6/\">探索Vue高阶组件</a></p>\n</blockquote>\n<h2 id=\"函数式组件-vue\"><a href=\"#函数式组件-vue\" class=\"headerlink\" title=\"函数式组件 (vue)\"></a>函数式组件 (vue)</h2><p>标记组件为functional，无状态(没有响应式数据)，无实例(没有this上下文)，<strong>组件需要的一切都是通过上下文传递</strong>，在一定程度上达到了复用。有两种方式可以定义函数式组件，一是通过<code>render function</code>形式，二是通过使用<code>单文件组件</code>。 目前对于单文件形式的函数式组件在模板编译、scoped css 和 热重载方面都得到了良好支持。 模板中的表达式会在函数式渲染上下文中求值，这就意味着在模板中，prop需要以<code>props.xx</code>的形式访问。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// render function</span></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> &#123;</span><br><span class=\"line\">  functional: <span class=\"literal\">true</span>,</span><br><span class=\"line\">  props: &#123;&#125;,</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">render</span>(<span class=\"params\">h, &#123; props, children, slots, data, parent, listeners, injections &#125;</span>)</span> &#123;&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">&lt;!-- 单文件形式 --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">template</span> <span class=\"attr\">functional</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">v-bind</span>=<span class=\"string\">&quot;data.attrs&quot;</span> <span class=\"attr\">v-on</span>=<span class=\"string\">&quot;listener&quot;</span>&gt;</span>&#123;&#123; parent.$someProperty &#125;&#125;<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">template</span>&gt;</span></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p><a href=\"https://codesandbox.io/s/yv4l2rnm4x\">Live Demo</a></p>\n<blockquote>\n<p>推荐文章：</p>\n<ul>\n<li><a href=\"https://alligator.io/vuejs/functional-components/\">Functional Components in Vue.js</a></li>\n<li><a href=\"https://itnext.io/whats-the-deal-with-functional-components-in-vue-js-513a31eb72b0\">What’s the deal with functional components in Vue.js?</a> <ul>\n<li><a href=\"https://github.com/daprahamian/vue-render-functions-example\">demo</a></li>\n<li><a href=\"https://upload-images.jianshu.io/upload_images/3152495-58990312b685ea50.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\">文章快照</a></li>\n</ul>\n</li>\n</ul>\n</blockquote>\n<h2 id=\"模板复用\"><a href=\"#模板复用\" class=\"headerlink\" title=\"模板复用\"></a>模板复用</h2><p>Vuex, Mixins, hooks, HOC 都是在二级上进行高度封装，考验开发者的编程功底。目前还有一个解决复用的方法，例如阿里的<a href=\"https://alibaba.github.io/ice/iceworks\">飞冰</a>, 通过穷举模板，进行复用。</p>\n<h1 id=\"React-三种状态共享方案\"><a href=\"#React-三种状态共享方案\" class=\"headerlink\" title=\"React 三种状态共享方案\"></a>React 三种状态共享方案</h1><ol>\n<li><p><a href=\"https://reactjs.org/docs/render-props.html\">渲染属性（Render Props）</a>: 使用一个值为函数的prop来传递需要动态渲染的nodes或组件</p>\n</li>\n<li><p><a href=\"https://reactjs.org/docs/higher-order-components.html\">高阶组件（Higher-Order Components）</a>： 一个函数接受一个组件作为参数，经过一系列加工后，最后返回一个新的组件。</p>\n</li>\n<li><p><a href=\"https://reactjs.org/docs/hooks-intro.html#___gatsby\">React Hooks</a> <strong>状态逻辑复用</strong>，只共享数据处理逻辑，不会共享数据本身。</p>\n<p> <strong>a. useState</strong><br>它的作用就是用来声明状态变量。useState这个函数接收的参数是我们的状态初始值（initial state），它返回了一个数组，这个数组的第[0]项是当前当前的状态值，第[1]项是可以改变状态值的方法函数。</p>\n<p> <strong>b. useEffect</strong></p>\n<ul>\n<li><p>解绑副作用：让我们传给useEffect的副作用函数返回一个新的函数即可。这个新的函数将会在组件下一次重新渲染之后执行。</p>\n</li>\n<li><p>跳过不必要的副作用： 只需要给useEffect传第二个参数即可。用第二个参数来告诉react只有当这个参数的值发生改变时，才执行我们传的副作用函数（第一个参数）。当我们第二个参数传一个空数组[]时，其实就相当于只在首次渲染的时候执行。不过这种用法可能带来bug，少用。</p>\n</li>\n</ul>\n</li>\n</ol>\n<p><img src=\"https://user-images.githubusercontent.com/17926741/98777658-1b4b1b00-242c-11eb-9eaa-de0e0ea2ccf1.png\"></p>\n<blockquote>\n<p>推荐文章<br><a href=\"https://github.com/dt-fe/weekly/blob/master/80.%E7%B2%BE%E8%AF%BB%E3%80%8A%E6%80%8E%E4%B9%88%E7%94%A8%20React%20Hooks%20%E9%80%A0%E8%BD%AE%E5%AD%90%E3%80%8B.md\">精读《怎么用 React Hooks 造轮子》</a><br><a href=\"https://juejin.im/post/5be3ea136fb9a049f9121014\">30分钟精通React Hooks</a></p>\n</blockquote>\n","categories":["前端"],"tags":["vue"]},{"title":"不为人知的Chrome devtools!","url":"http://example.com/2018/12/11/2018-12-11-about-chrome-devtools/","content":"<p>说到chrome devtools 使用技巧，今天想和大家分享两个，网页截屏和快速引入并引用npm库。除此之外，还有一个大惊喜~</p>\n<h2 id=\"网页截屏\"><a href=\"#网页截屏\" class=\"headerlink\" title=\"网页截屏\"></a>网页截屏</h2><p>如何实现网页截屏，大家可能会想使用微信的截图工具就可以呀！是的，笔者往常也是这样截图的。那如何截取长页面的内容呢? 我想微信截图恐怕就无法实现了，这时候你可能会借用‘外力’，没错，我们可以使用软件<a href=\"https://faststone-capture.en.softonic.com/\">FastStone Capture</a>。那有没有不借助‘外力’也能截图长图呢，答案是肯定的。 </p>\n<p><img src=\"https://user-images.githubusercontent.com/17926741/98777152-323d3d80-242b-11eb-8e8a-9466db06b41c.png\" alt=\"FastStone Capture 滚动截图\"></p>\n<p>那如何利用devtools实现截图呢？</p>\n<p>1、<code>F12</code>打开开发者工具;<br>2、利用快捷键 <code>ctrl + shift + p</code>调出命令行;<br>3、输入screen，选择 <code>capture full size screenshot</code>(捕捉全尺寸屏幕截图)</p>\n<p>锵锵~~ 生成当前页面的长图。是不是很惊喜，执行一个命令就完成了。<br><img src=\"https://user-images.githubusercontent.com/17926741/98777151-310c1080-242b-11eb-94e0-09efc99cc84c.png\" alt=\"全尺寸效果图\"></p>\n<p>有时你可能只想截取一部分内容，但内容又有些长。这时<code>capture full size screenshot</code> 和 <code>capture screenshot</code> 都不满足需求，别忘了，我们还有<code>capture node screenshot</code>。</p>\n<p><img src=\"https://user-images.githubusercontent.com/17926741/98777133-2c475c80-242b-11eb-8ff7-0d1ffecb1be4.gif\" alt=\"捕捉节点屏幕截屏\"></p>\n<p><em>温馨提示</em>：<br><code>capture full size screenshot</code> 捕捉整个网页屏幕截图<br><code>capture node screenshot</code> 捕捉节点网页屏幕截图<br><code>capture screenshot</code> 捕捉当前屏幕截图</p>\n<h2 id=\"快速引入并应用npm库\"><a href=\"#快速引入并应用npm库\" class=\"headerlink\" title=\"快速引入并应用npm库\"></a>快速引入并应用npm库</h2><p>有时候我们想学习一个库( 很有兴致的那种 )，可能往往就在环境搭建的过程中放弃了学习( 苦笑 )。今天介绍的这个想必能解决你的痛点！</p>\n<p>1、获取并添加Chrome扩展程序：<a href=\"https://chrome.google.com/webstore/detail/console-importer/hgajpakhafplebkdljleajgbpdmplhie/related\">Console Importer</a><br>2、如果你想练习下 <code>lodash</code> 里的方法，你可以执行 <code>$i(&#39;lodash&#39;)</code> 将 <code>lodash</code> 库引入，接下来就可以愉快把玩工具库啦。对于学习使用某个工具库真的很方便，有木有~</p>\n<p><img src=\"https://user-images.githubusercontent.com/17926741/98777128-2b162f80-242b-11eb-910d-8598adfc306d.png\" alt=\"lodash练习\"></p>\n<h3 id=\"你可能会遇到的问题\"><a href=\"#你可能会遇到的问题\" class=\"headerlink\" title=\"你可能会遇到的问题?\"></a>你可能会遇到的问题?</h3><p><strong>Q1: <code>$i</code> 不像预期的那样起作用</strong><br>一些网站可能已经把 <code>$i</code> 作为一个全局变量，这个扩展程序就无法重写覆盖它，这时你可以 <code>console.$i</code> 这样调用，也是一样的效果。</p>\n<p><strong>Q2: <code>$i</code> 无法导入资源</strong></p>\n<p><img src=\"https://user-images.githubusercontent.com/17926741/98777131-2baec600-242b-11eb-9ee3-1bf736bf440f.png\" alt=\"lodash导入报错\"></p>\n<p>出错的原因是这些网站采用了严格的内容安全政策(<code>Content Security Policy</code>)。你可以打开一个本地html，或者是用一个没有进行严格内容安全政策的网站进行 <code>$i(&#39;lodash&#39;)</code> 练习</p>\n<h2 id=\"彩蛋\"><a href=\"#彩蛋\" class=\"headerlink\" title=\"彩蛋\"></a>彩蛋</h2><p>想必大家在网上也看到过很多介绍console方法的文章，笔者觉得有些碎片化了。故借此机会，向大家推荐阅读<a href=\"https://developers.google.com/web/tools/chrome-devtools/\">devtools的开发者手册</a>（感觉是宝藏, 虽然有一定的学习门槛）</p>\n<p><img src=\"https://user-images.githubusercontent.com/17926741/98777158-336e6a80-242b-11eb-90a4-ed3fc61a7f9e.png\" alt=\"如何找到devtools开发者手册\"></p>\n<blockquote>\n<p>使用 Console API 可以向控制台写入信息、创建 JavaScript 配置文件，以及启动调试会话。</p>\n</blockquote>\n<ul>\n<li><a href=\"https://developers.google.com/web/tools/chrome-devtools/console/console-reference\">Console API Reference</a>介绍了<code>assert, clear, debug, dir, dirxml, error, group, groupCollapsed, groupEnd, info, log, profile, profileEnd, time, timeEnd, timeStamp, trace, warn</code>的使用，也提供了相关实例。</li>\n</ul>\n<blockquote>\n<p>Command Line API 包含一个用于执行以下常见任务的便捷函数集合：选择和检查 DOM 元素，以可读格式显示数据，停止和启动分析器，以及监控 DOM 事件。</p>\n</blockquote>\n<ul>\n<li><a href=\"https://developers.google.com/web/tools/chrome-devtools/console/command-line-reference\">Command Line Reference</a>一共介绍了21个方法:<br><code>$_, $0 - $4, $, $$, $x, clear, copy, debug, dir, dirxml, inspect, getEventListeners, keys, monitor, monitorEvents, profile and profileEnd, table, undebug, unmonitor, unmonitorEvents, values</code></li>\n</ul>\n<p>我猜有人犯懒了，链接都懒得打开啦…<br><img src=\"https://user-images.githubusercontent.com/17926741/98777123-29e50280-242b-11eb-9ddb-a4d60c3318a2.gif\" alt=\"别跑，快回来学习！\"></p>\n<p>那我就把 <code>devtools</code> 手册目录贴出来啦，说不好一看又感兴趣了呢~</p>\n<p><img src=\"https://user-images.githubusercontent.com/17926741/98777154-323d3d80-242b-11eb-911a-6b66ea0d2805.png\" alt=\"开发者手册目录\"></p>\n<p>单词我们都认识，能不能学好就靠你自己啦…前面推荐的<code>Console API Reference</code>和<code>Command Line Reference</code> 已经是中文文档了哈，莫慌莫慌…</p>\n<p><img src=\"https://user-images.githubusercontent.com/17926741/98777155-32d5d400-242b-11eb-9a0d-91a3854d0450.jpg\" alt=\"加油！\"></p>\n","categories":["前端"],"tags":["Chrome"]},{"title":"快应用-开通oppo账号服务艰辛之路","url":"http://example.com/2018/09/07/2018-09-07-quickapp-oppo-account/","content":"<p>最近在开发一个快应用，其实不能说是一个快应用啦，是一个用户登录注册的功能。其中需要涉及到oppo账号授权。</p>\n<p>这个事情还得从两个帐号说起，<code>快应用开发者帐号</code>和<code>OPPO开发者帐号</code>。</p>\n<h2 id=\"快应用开发者帐号\"><a href=\"#快应用开发者帐号\" class=\"headerlink\" title=\"快应用开发者帐号\"></a>快应用开发者帐号</h2><p>首先先说下这个<code>快应用开发者帐号</code>，其作用就是绑定厂商和上传快应用。对于快应用帐号如何申请，官网和各个厂商的开发平台都有相应的文档教程，这里笔者就不介绍了。但有有一点需要提醒一下，快应用开发者帐号必须<strong>完善资料</strong>，审核通过了才能在顶部有<strong>开发者中心</strong>这一项，上面说到的<strong>厂商帐号绑定</strong>就在这个栏目里。如下图所示</p>\n<p><img src=\"https://user-images.githubusercontent.com/17926741/98777983-9e6c7100-242c-11eb-8c3e-4b8a53535168.png\" alt=\"开发者中心\"></p>\n<h2 id=\"OPPO开发者帐号\"><a href=\"#OPPO开发者帐号\" class=\"headerlink\" title=\"OPPO开发者帐号\"></a>OPPO开发者帐号</h2><p>这个帐号与<code>快应用开发者帐号</code>是多对一的关系，一个<code>快应用开发者帐号</code>只能绑定一个<code>OPPO开发者帐号</code>，但一个<code>OPPO开发者帐号</code>可对应多个<code>快应用开发者帐号</code>。至于这个OPPO开发者帐号怎么用呢，这里先保留。</p>\n<p>先说下原由，为何故事因这两个帐号而起。</p>\n<hr>\n<p>事情是这样的……</p>\n<p>有一天，产品给我这两个帐号，我当时还啥也不懂，你给我就收下咯。直到开发到oppo授权阶段，我愣住了。</p>\n<p>在<code>快应用开发者帐号</code>里，绑定的是oppo帐号A（如下图），但是给我的是oppo帐号B。这两个有啥关系！！我着急了，赶紧告诉我们产品，这两个帐号没有本质的联系，是不对的。他又找了给这两个帐号的相关人员，历经波折……······…….嗯。终于找到了oppo帐号A，此时的我已经感动的老泪纵横【夸张了】。</p>\n<p><img src=\"https://user-images.githubusercontent.com/17926741/98777984-9f050780-242c-11eb-9890-8df1d61559b5.png\" alt=\"厂商帐号绑定\"></p>\n<p>所以正确的流程应该是用与<code>快应用开发者帐号</code>绑定的<code>OPPO开发者帐号</code>登录到OPPO平台进行<strong>开通帐号服务</strong>。【也许这里有人会吐槽，很简单的流程为何还写了这么多。嗯，他说的也不无道理，但是记录的目的就是防止有人也跟我一样，迷糊了一圈】</p>\n<p><img src=\"https://user-images.githubusercontent.com/17926741/98777968-9a405380-242c-11eb-99cc-e81de88fc7d2.png\" alt=\"开通帐号服务流程图\"></p>\n<p>你是不是以为找到正确的oppo帐号A就ok。当时的我也跟你一样的想法！事实上呢，好吧！是我（们）想太多，事情并没有这么简单。</p>\n<p>我调用<code>account.authorize</code>还是获取不到授权信息。重点是获取服务提供商<code>account.getProvider()</code>都获取不到，这个数据应该不需要什么多余操作就能获取到的呀。我试了好几个安卓设备都是一样的结果，空空如也<del>~</del></p>\n<p>组里就我自己接触了快应用，也无人可解问。接着我就开始各种加群，QQ群（<code>oppo开发者交流群</code>，微信群（<code>快应用官方技术交流群</code>）。我就各种问呀问呀，虽然回答很慢（毕竟大家都有自己的工作嘛），但是都很实用。群里有各个厂商的技术大佬在，最为活跃的还属华为的技术大大，很感恩，因为他，我接触到了oppo快应用相关的技术大佬，为后期工作打下了深厚的基础。</p>\n<blockquote>\n<p>“三人行，必有我师焉”</p>\n</blockquote>\n<p>没错，接下来还是继续加群。接下来的第一个群，解决了无法获取服务提供商的问题。你猜是怎么解决的？答案很简单就是换了个快应用调试器。。</p>\n<p><img src=\"https://user-images.githubusercontent.com/17926741/98777980-9dd3da80-242c-11eb-9cda-af8c34cf5237.png\" alt=\"what?\"></p>\n<p>原因是这样的，我这个oppo手机内置的快应用运行平台是2.1的灰度版本暂时不能用联盟官网的调试器，后来是oppo技术人员单独发我一个调试器进行调试，不过他也表名，此举只是临时方案，后面会支持联盟官网的调试器。<strong>系统设置 - 应用管理 - 快应用</strong>可查看快应用版本。</p>\n<p><img src=\"https://user-images.githubusercontent.com/17926741/98777993-a0cecb00-242c-11eb-917c-2411693e2c6a.png\" alt=\"oppo手机快应用的版本\"></p>\n<p>好了，有了能调试的调试器。那就来看看账号服务是否能走通吧~</p>\n<p>无奈还是不行，好在不像之前，已经有相关错误提示啦~</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">fail:   code &#x3D; 200, data &#x3D; generic error</span><br></pre></td></tr></table></figure>\n<p>可行官网也没介绍这200是啥错。那我就只能厚着脸皮问oppo技术大大了，好在遇到了一群暖心的小哥哥小姐姐，被告知：要将快应用先提交（不用一定要上架），此举只是为了能申请账号服务，这里顺便提一句，原生应用和快应用申请账号服务是分开的。看到后面你就会明白这句话是啥意思啦~</p>\n<p>那接下来就是提交快应用。这次提交你可别提交一个到处bug的rpk。至少是功能完整，就差账号服务这一功能，提交完成就是坐等审核通过啦。建议你加下<code>快应用官方客服</code>的微信，这样有问题你可以直接问他，或是你的快应用提交有误之处，他们也可能及时联系到你，方便你们沟通。</p>\n<p><img src=\"https://user-images.githubusercontent.com/17926741/98777986-9f9d9e00-242c-11eb-9b9a-598861fb7256.png\" alt=\"提交快应用\"></p>\n<p>·········………·········经过漫长的审核，终于通过啦~</p>\n<p>接下来就是讲讲申请账号服务啦</p>\n<p>这里，我又加入了另一个群，没错就是关于账号服务的群。</p>\n<p>由于目前oppo关于快应用开通账号的页面还没开放，相关技术给了我线上地址，这里就不展示了。页面内容与原生应用开通账号服务的模样一般无二。如下图所示，我们申请的就是<strong>第一项推送能力项openid</strong>。</p>\n<p><img src=\"https://user-images.githubusercontent.com/17926741/98777974-9ca2ad80-242c-11eb-920d-4205fc70acec.png\" alt=\"快应用开通账号服务\"></p>\n<p>点击<code>立即开通</code>，里头长这样。</p>\n<p><img src=\"https://user-images.githubusercontent.com/17926741/98777973-9c0a1700-242c-11eb-8ff9-3e250dac8fec.png\" alt=\"开通openid\"></p>\n<p>那红框这一块如何填写呢? <code>随便填</code><br>这里笔者觉得有些粗糙了，相信今后这一块会完善好。这一点我个人觉得还是华为做的好一些，开放文档里也写的很明了。</p>\n<p><img src=\"https://user-images.githubusercontent.com/17926741/98777990-a0363480-242c-11eb-84f9-46e8c7af6aa3.gif\"></p>\n<p>走到这一步就差不多了，就等审核通过啦。<br>···<br>审核通过啦，当我再次调试页面时提示我更新到最新版，可能是我刚好赶上新版调试器发布。时间总是如此的巧合。。</p>\n<p><img src=\"https://user-images.githubusercontent.com/17926741/98777976-9d3b4400-242c-11eb-8d72-72d515648b20.png\" alt=\"v1020\"></p>\n<p>更新完调试器，在调试页面。我真的感动了，调用账号授权接口拿到code了。。。(当时心情无语言表)</p>\n<p>（完）</p>\n<p><em>此文只是记录快应用账号接入的过程，仅供借鉴，随着快应用的发展，各家厂商产品的完善，大家可能不会像笔者这般纠结，如能帮助到大家，庆幸写下此文。</em></p>\n","categories":["前端"],"tags":["快应用"]},{"title":"什么？错过了Vue CLI 2！你还要错过Vue CLI3？","url":"http://example.com/2018/08/06/2018-08-06-dont-miss-vue-cli3/","content":"<h1 id=\"Vue-CLI-产生的背景\"><a href=\"#Vue-CLI-产生的背景\" class=\"headerlink\" title=\"Vue CLI 产生的背景\"></a>Vue CLI 产生的背景</h1><p>在<code>Vue CLI</code>出现之前，你可能要花费好几天的时间搭建项目的开发环境，如果你事先不了解<code>webpack</code>，你可能会又花费大把的时间熟悉<code>webpack</code>。就这样，一周过去了，你的项目还没有真正启动起来。<br>为了让开发者从纠结配置中解放出来，专注于撰写应用程序。<code>Vue CLI</code>也就因此而产生。它不仅确保了各种构建工具能够基于智能的默认配置即可平稳衔接，还提供了配置调整的灵活性。</p>\n<h1 id=\"Vue-CLI历史\"><a href=\"#Vue-CLI历史\" class=\"headerlink\" title=\"Vue CLI历史\"></a>Vue CLI历史</h1><p><code>Vue CLI </code>到目前为止经历了两个大版本，<code>CLI 2</code> 和 <code>CLI 3</code>。很多人可能会好奇从 <code>CLI 2</code>升级到<code>CLI 3</code>会有哪些新的改变，接下来就一边回顾<code>CLI 2</code>，一边为大家解读<code>CLI 3</code>的新特性。</p>\n<h1 id=\"创建一个项目\"><a href=\"#创建一个项目\" class=\"headerlink\" title=\"创建一个项目\"></a>创建一个项目</h1><p><code>CLI 2</code>和<code>CLI 3</code>第一个区别是npm包的包名，<code>CLI 3</code>并没有沿用<code>CLI 2</code>的<code>vue-cli</code>，而是另起为<code>@vue/cli</code>。创建项目方面也发生了变化，<code>CLI 2</code> 可以选择根据模板初始化项目，而<code>CLI 3</code>并未重新开发模板，如果开发者想要像<code>CLI 2</code>一样使用模板初始化项目，可全局安装一个桥接工具<code>@vue/cli-init</code>。</p>\n<p>1、<code>CLI 2</code> 全局安装并创建项目</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install -g vue-cli</span><br><span class=\"line\"><span class=\"comment\"># 或者</span></span><br><span class=\"line\">npm install -g vue-cli@x.x.x // 指定安装某一版本</span><br><span class=\"line\"></span><br><span class=\"line\">vue init &lt;template-name&gt; &lt;project-name&gt;</span><br><span class=\"line\"><span class=\"comment\"># 例如：vue init webpack vue-test</span></span><br></pre></td></tr></table></figure>\n<p><em>注意：这里的<code>CLI 2</code>是2.9.6。</em></p>\n<p><code>&lt;template-name&gt;</code>：表示模板名称，可以通过vue list查看可用的模板，在这里官方提供了6种模板，分别为：</p>\n<ul>\n<li>  <code>browserify</code>——一个全面的<code>Browserify + vueify</code> 的模板，运行起来带有热重载，保存时 lint 校验，单元测试。</li>\n<li><code>browserify-simple</code>——一个简单<code>Browserify + vueify</code>的模板，不包含其他功能，让你快速的搭建vue的开发环境。</li>\n<li><code>pwa</code>——一个基于<code>webpack</code>模板的渐进式的网页应用程序模板。</li>\n<li><code>simple</code>——一个最简单的单页应用模板。</li>\n<li><code>webpack</code>——一个全面的<code>webpack + vue-loader</code>的模板，运行起来带有热重载，保存时 lint 校验和CSS扩展。</li>\n<li><code>webpack-simple</code>——一个简单<code>webpack + vue-loader</code>的模板，能让你快速搭建一个vue的开发环境。</li>\n</ul>\n<p><img src=\"https://user-images.githubusercontent.com/17926741/98778990-1f783800-242e-11eb-8681-f33344d7a0d5.png\" alt=\"官方提供的6种模板\"></p>\n<p>初始化过程中会确认项目的项目名、作者等信息，大家可根据需求自行修改。</p>\n<p>2、<code>CLI 3</code>全局安装并创建一个项目</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install -g @vue/cli</span><br><span class=\"line\"><span class=\"comment\"># 或者</span></span><br><span class=\"line\">yarn global add @vue/cli</span><br><span class=\"line\"><span class=\"comment\"># 创建项目</span></span><br><span class=\"line\">vue create &lt;project-name&gt;</span><br><span class=\"line\"><span class=\"comment\"># 例如：vue create vue-3.0-demo</span></span><br><span class=\"line\"><span class=\"comment\"># 或</span></span><br><span class=\"line\"><span class=\"comment\"># 使用init 初始化项目</span></span><br><span class=\"line\">npm install -g @vue/cli-init</span><br><span class=\"line\"><span class=\"comment\"># `vue init` 的运行效果将会跟 `vue-cli@2.x` 相同</span></span><br><span class=\"line\">vue init webpack vue-3.0-demo</span><br></pre></td></tr></table></figure>\n\n<p>当我们用<code>CLI 3</code>的方式创建项目，输入<code>vue create vue-3.0-demo</code>命令后，你会发现在创建项目的路上总是有位“记者大哥”横路拦截，问你这问你那，你还必须做出选择。</p>\n<hr>\n<p>记者大哥：“欢迎进入<code>CLI 3</code>的世界，首先你得选取一个 preset。选择默认的设置可以快速创建一个新项目的原型，而手动设置则提供了更多的选择。你是选择默认配置，还是手动选择特性呢？”</p>\n<p>你：（心里活动：<code>“来都来了，为何不看看记者大哥到底搞什么鬼”</code>）“我选择了手动选择属性”</p>\n<p><img src=\"https://user-images.githubusercontent.com/17926741/98778969-1a1aed80-242e-11eb-9d8c-d042ec636c42.png\" alt=\"手动选取特性\"></p>\n<p>你：什么鬼？还给我来个多选题！首先<code>Babel</code>是必要的，不然拿什么来转换<code>ES6</code>语法，<code>TypeScript</code>？不会，略过。渐进式的程序应用，暂时也不涉及这个。<code>Router</code>勾上，作为一个移动M站，得有人来管理路由呀。<code>Vuex</code>一个状态管理器，后期要用再加上吧，反正也跑不了。css 预处理器，习惯使用<code>Less</code>，也加一。<code>Linter / Formatter</code>也加一，作为一个团队，没有人统一代码风格可不行。最后两个分别是单元测试和端对端测试，这里我就不加上了，没用过，期待今后有大神分享。</p>\n<p>选择完特性后，你以为就结束了，没想到，一步选错步步要你选。</p>\n<p>对于css预处理器方面，你毅然决然选择了<code>Less</code>；<br>但<code>linter / formatter</code> 配置，你懵逼了。这都是什么？？记者大哥介绍了一下：</p>\n<p><a href=\"https://github.com/eslint/eslint\">ESLint</a> 是一个语法规则和代码风格的检查工具，可以检测出你代码中潜在的问题，可以保证写出语法正确和风格统一的代码。<br><img src=\"https://user-images.githubusercontent.com/17926741/98778993-1f783800-242e-11eb-8d17-c1f3e8c235a6.png\" alt=\"选择linter配置.png\"></p>\n<ul>\n<li><code>ESLint with error prevention only</code>——只检测错误。</li>\n<li><code>ESLint + Airbnb config</code>——独角兽公司的<a href=\"https://github.com/airbnb/javascript\">Airbnb</a>，有人评价说“这是一份最合理的JavaScript编码规范”，它几乎涵盖了JavaScript的各个方面。</li>\n<li><code>ESLint + Standard config</code>——<a href=\"https://github.com/standard/standard\">standardJs</a>一份强大的JavaScript编码规范，自带linter和自动代码纠正。没有配置。自动格式化代码。可以在编码早期发现规范问题和低级错误。</li>\n<li><code>ESLint + Prettier</code>—— <a href=\"https://github.com/prettier/prettier\">Prettier</a> 作为代码格式化工具，能够统一整个团队的代码风格。</li>\n</ul>\n<p>等他介绍完，你心里大概有点谱了，这里你选择了 <code>ESLint + Standard config</code>。</p>\n<p>lint有两种检查时机，一是用户保存文件的时候，二是用户提交文件到git的时候。你就选了<code> Lint on save</code>，有错及时解决嘛。</p>\n<p>终于“记者大哥”告诉你接下来这个问题是最后一个问题咯。</p>\n<p><img src=\"https://user-images.githubusercontent.com/17926741/98778974-1be4b100-242e-11eb-9132-05d0209ea4c7.png\"></p>\n<p>记者大哥：你是喜欢把Babel、ESLint等配置信息全放在package.json文件里呢，还是单独文件管理？</p>\n<p>你：一个一个文件比较好，根据文件名就知道这是谁的配置，方便维护。</p>\n<p>记者大哥：那你是否想把今天你手动选择的preset保存为未来项目的preset呢？</p>\n<p>你：<br><img src=\"https://user-images.githubusercontent.com/17926741/98778976-1c7d4780-242e-11eb-9142-ba662c760b2c.png\" alt=\"说好的最后一个呢！！\"></p>\n<p>……保存！</p>\n<hr>\n<p><strong>温馨提示</strong>：<em>如果你是用windows，在进行创建项目的时候，最好使用cmd，在cmd里你可以通过箭头上下选择和空格选中。如果你用git bash 可能会出现箭头和空格都没有请选择和选中作用。</em></p>\n<p>这里通过一个漫长的对话我们自定义的一个preset，此时如果你需要创建新工程，这时候你就会发现多了一个preset，就是最初你自己设置的。你可以选择自己之前保存preset的，也可以再次开启“采访模式”。</p>\n<p><img src=\"https://user-images.githubusercontent.com/17926741/98778971-1ab38400-242e-11eb-883f-257ca1a322c1.png\" alt=\"新添的preset\"></p>\n<h2 id=\"CLI-2-的项目结构\"><a href=\"#CLI-2-的项目结构\" class=\"headerlink\" title=\"CLI 2 的项目结构\"></a>CLI 2 的项目结构</h2><p><img src=\"https://user-images.githubusercontent.com/17926741/98778966-18e9c080-242e-11eb-87df-eec44d66af28.png\" alt=\"vue cli 2.9.6项目结构.png\"><br>对于<code>CLI 2</code>这个项目结构，主要的也是最重要的在于bulid和config者两个目录。bulid是项目构建的相关代码，config是项目开发环境配置。</p>\n<p>接下来就先从<code>webpack.base.conf.js</code>开始依次介绍build和config两个目录下的相关功能。</p>\n<h3 id=\"webpack-base-conf-js\"><a href=\"#webpack-base-conf-js\" class=\"headerlink\" title=\"webpack.base.conf.js\"></a>webpack.base.conf.js</h3><p><code>webpack.base.conf.js</code>是webpack的基础配置，是dev和prod的公共配置文件。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> path = <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;path&#x27;</span>)</span><br><span class=\"line\"><span class=\"keyword\">const</span> utils = <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;./utils&#x27;</span>)</span><br><span class=\"line\"><span class=\"keyword\">const</span> config = <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;../config&#x27;</span>)</span><br><span class=\"line\"><span class=\"keyword\">const</span> vueLoaderConfig = <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;./vue-loader.conf&#x27;</span>)</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>path——该模块提供了一些用于处理文件路径的小工具</li>\n<li>utils——给整个CLI提供方法</li>\n<li>config——开发环境的配置</li>\n<li>vueLoaderConfig——分析是否是生产环境，然后将根据不同的环境来加载配置功能</li>\n</ul>\n<p>在这个文件里一共实现了两个方法。一是合并path路径的，另一个是创建Eslint的Rules。而剩余部分就是webpack的基础配置，这里简化了webpack结构，简化的结果其实就是webpack的一个骨架，如果在配置上遇到问题，可去<a href=\"http://webpack.github.io/\">webpack</a>查证。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">...</span><br><span class=\"line\"><span class=\"built_in\">module</span>.exports = &#123;</span><br><span class=\"line\">  entry: &#123;&#125;, <span class=\"comment\">// 编译入口文件</span></span><br><span class=\"line\">  output: &#123;&#125;, <span class=\"comment\">// 编译输出路径</span></span><br><span class=\"line\">  resolve: &#123;&#125;, <span class=\"comment\">// 一些解决方案配置</span></span><br><span class=\"line\">  <span class=\"built_in\">module</span>: &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 不同类型文件加载器配置</span></span><br><span class=\"line\">    rules: []</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  ...</span><br><span class=\"line\">  <span class=\"comment\">// 这些选项用于配置polyfill或mock某些node.js全局变量和模块。</span></span><br><span class=\"line\">  <span class=\"comment\">// 这可以使最初为nodejs编写的代码可以在浏览器端运行</span></span><br><span class=\"line\">  node: &#123;...&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>关于path有兴趣的可前往<a href=\"https://nodejs.org/api/path.html\">node</a>学习，接下来重点介绍下<code>utils.js</code>，<code>config</code>和<code>vue-loader.conf</code>。</p>\n<h3 id=\"utils-js\"><a href=\"#utils-js\" class=\"headerlink\" title=\"utils.js\"></a>utils.js</h3><p>utils.js文件中总共实现了4个方法：<code>assetsPath</code>、<code>cssLoaders</code>、<code>styleLoaders</code>、<code>createNotifierCallback</code>。</p>\n<ul>\n<li>assetsPath——返回不同环境下的static目录位置</li>\n<li>cssLoaders——为不同的css预处理器提供一个统一的生成方式</li>\n<li>styleLoaders——为那些独立的style文件创建加载器配置</li>\n<li>createNotifierCallback——以类似浏览器的通知的形式展示信息</li>\n</ul>\n<h3 id=\"config\"><a href=\"#config\" class=\"headerlink\" title=\"config\"></a>config</h3><p>config关键文件是<code>index.js</code>。这个文件是开发环境和生产环境的基本配置。在这个文件里开发者可在dev设置开发环境的静态路径、本地服务器配置项、Eslint、SourceMaps和代理，也可在build设置生产环境是否开启gzip压缩，以及压缩后缀名的设置等。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">...</span><br><span class=\"line\"><span class=\"built_in\">module</span>.exports = &#123;</span><br><span class=\"line\">  dev: &#123;...&#125;,</span><br><span class=\"line\">  build: &#123;...&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"vue-loader-conf\"><a href=\"#vue-loader-conf\" class=\"headerlink\" title=\"vue-loader.conf\"></a>vue-loader.conf</h3><p>这个文件的内容相对比较少。首先，vue文件中的css loader将在生产环境下把css文件抽取到一个独立的文件中；其次是根据不同的环境，引入不同的source map配置文件；最后设置是否开启缓存破坏。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&#x27;use strict&#x27;</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> utils = <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;./utils&#x27;</span>)</span><br><span class=\"line\"><span class=\"keyword\">const</span> config = <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;../config&#x27;</span>)</span><br><span class=\"line\"><span class=\"keyword\">const</span> isProduction = process.env.NODE_ENV === <span class=\"string\">&#x27;production&#x27;</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> sourceMapEnabled = isProduction</span><br><span class=\"line\">  ? config.build.productionSourceMap</span><br><span class=\"line\">  : config.dev.cssSourceMap</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">module</span>.exports = &#123;</span><br><span class=\"line\">  loaders: utils.cssLoaders(&#123;</span><br><span class=\"line\">    sourceMap: sourceMapEnabled,</span><br><span class=\"line\">    extract: isProduction</span><br><span class=\"line\">  &#125;),</span><br><span class=\"line\">  cssSourceMap: sourceMapEnabled,</span><br><span class=\"line\">  cacheBusting: config.dev.cacheBusting,</span><br><span class=\"line\">  transformToRequire: &#123;</span><br><span class=\"line\">    video: [<span class=\"string\">&#x27;src&#x27;</span>, <span class=\"string\">&#x27;poster&#x27;</span>],</span><br><span class=\"line\">    source: <span class=\"string\">&#x27;src&#x27;</span>,</span><br><span class=\"line\">    img: <span class=\"string\">&#x27;src&#x27;</span>,</span><br><span class=\"line\">    image: <span class=\"string\">&#x27;xlink:href&#x27;</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>关于webpack公共配置讲完了，接下来我们就一起学习下在dev和prod环境各自的配置吧。</p>\n<h3 id=\"webpack-dev-conf-js\"><a href=\"#webpack-dev-conf-js\" class=\"headerlink\" title=\"webpack.dev.conf.js\"></a>webpack.dev.conf.js</h3><p>这个文件引入了<code>webpack-merge</code>，意在将公共配置文件和dev配置合并。从代码里我们可以发现，dev环境又新增了一些配置项。</p>\n<ul>\n<li>给独立的style文件添加了sourceMap功能，有了它，出错的时候，除错工具将直接显示原始代码，而不是转换后的代码。</li>\n<li>引入devtool。</li>\n<li>配置devServer，包括热部署、代理、启动程序的时候自动在浏览器打开主页面等。</li>\n<li>新增一些插件，包括热替换、<code>webpack.NamedModulesPlugin</code>在热加载时直接返回更新文件名、<code>html-webpack-plugin</code>生成html文件等。</li>\n</ul>\n<p>最后一个函数是为了确保启动程序时，如果端口被占用时，会通过portfinder来发布新的端口。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">...</span><br><span class=\"line\"><span class=\"keyword\">const</span> devWebpackConfig = merge(baseWebpackConfig, &#123;</span><br><span class=\"line\">  <span class=\"built_in\">module</span>: &#123; ... &#125;,</span><br><span class=\"line\">  devtool: config.dev.devtool,</span><br><span class=\"line\">  devServer: &#123; ... &#125;,</span><br><span class=\"line\">  plugins: [ ... ]</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">module</span>.exports = <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\">(<span class=\"params\">resolve, reject</span>) =&gt;</span> &#123; ... &#125;)</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"webpack-prod-conf-js\"><a href=\"#webpack-prod-conf-js\" class=\"headerlink\" title=\"webpack.prod.conf.js\"></a>webpack.prod.conf.js</h3><p>相比 <code>webpack.dev.conf.js</code>，这个文件多引入了几个依赖，主要是为了压缩CSS和JS。在文件配置上多了一个output，将js文件打包成多个chuck，用hash值命名，来解决缓存策略。</p>\n<p>到这里<code>CLI 2</code>的整个配置也就接近尾声了。剩下的还有<code>check-version.js</code>和<code>bulid.js</code>两个文件。</p>\n<h3 id=\"check-version-js\"><a href=\"#check-version-js\" class=\"headerlink\" title=\"check-version.js\"></a>check-version.js</h3><p>这个文件主要是用来检测当前环境中的node和npm版本和我们需要的是否一致的。</p>\n<h3 id=\"bulid-js\"><a href=\"#bulid-js\" class=\"headerlink\" title=\"bulid.js\"></a>bulid.js</h3><p>这个文件刚开始通过<code>check-versions</code>判断当前的node和npm版本号，如果现有的npm或者node的版本比定义的版本低，则生成一段警告。接下来，先删除打包目标目录下的文件，再进行打包，直至打包完成。</p>\n<p>我们走马观花的学习了<code>CLI 2</code>的配置，估计大家也都累了。那接下来就来一段采访吧~~期待不，哈哈。</p>\n<h2 id=\"CLI-3的项目结构\"><a href=\"#CLI-3的项目结构\" class=\"headerlink\" title=\"CLI 3的项目结构\"></a>CLI 3的项目结构</h2><p><img src=\"https://user-images.githubusercontent.com/17926741/98778997-20a96500-242e-11eb-9165-96230508123b.png\" alt=\"CLI 3项目结构.png\"></p>\n<p>从<code>CLI 3</code>的整个项目结构我们可以发现，这个结构很简单，没有相关的配置文件或复杂的目录结构。<code>CLI 3</code>仅生成构建应用程序所需的文件，让使用者不用关心这些工具的具体配置，从而降低了工具的使用难度。</p>\n<p>其实通过阅读<code>CLI 3</code>的官方文档，你可能已经知道，官方内置了一个CLI服务（<code>@vue/cli-service</code>），作为一个开发环境的依赖，局部安装在<code>@vue/cli</code>创建的项目中。如果你真想修改webpack的相关配置，可在项目的根目录下（和<code>package.json同级</code>）创建一个vue.config.js配置文件，这个文件一旦存在就会被<code>@vue/cli-service</code>自动加载。也可直接使用<code>package.json</code>中的<code>vue</code>字段。</p>\n<blockquote>\n<p>一个没有好奇心的程序猿，不是一个更好的程序猿。</p>\n</blockquote>\n<p>如果你已经满足于官方的介绍，那也就到此结束漫长的阅读之旅啦（偷偷告诉你后面还有新特性的精彩内容）。如果你也像我一样，充满了好奇心，就跟我再去探索一番。</p>\n<p>从<code>CLI 2</code>到<code>CLI 3</code>，初期可能没有官方文档。如果你真想探个究竟，可以从启动项目入手。</p>\n<p><code>CLI 2</code>启动方式是<code>webpack-dev-server --inline --progress --config build/webpack.dev.conf.js</code><br>这里用<code>webpack-dev-server</code>搭一个服务。</p>\n<ul>\n<li>–inline：启动inline模式来自动刷新页面</li>\n<li>–progress：显示打包的进度</li>\n<li>–config build/webpack.dev.conf.js：指定要用的是哪个配置文件</li>\n</ul>\n<p><code>CLI 3</code>启动方式是<code>vue-cli-service serve</code></p>\n<p><code>vue-cli-service</code>就是CLI服务，你可全局搜索一下，位于<code>node_modules\\@vue\\cli-service\\bin</code></p>\n<h3 id=\"vue-cli-service-js\"><a href=\"#vue-cli-service-js\" class=\"headerlink\" title=\"vue-cli-service.js\"></a>vue-cli-service.js</h3><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#!/usr/bin/env node</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> semver = <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;semver&#x27;</span>)</span><br><span class=\"line\"><span class=\"keyword\">const</span> &#123; error &#125; = <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;@vue/cli-shared-utils&#x27;</span>)</span><br><span class=\"line\"><span class=\"keyword\">const</span> requiredVersion = <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;../package.json&#x27;</span>).engines.node</span><br><span class=\"line\"></span><br><span class=\"line\">...</span><br><span class=\"line\"><span class=\"keyword\">const</span> Service = <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;../lib/Service&#x27;</span>)</span><br><span class=\"line\"><span class=\"keyword\">const</span> service = <span class=\"keyword\">new</span> Service(process.env.VUE_CLI_CONTEXT || process.cwd())</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> rawArgv = process.argv.slice(<span class=\"number\">2</span>)</span><br><span class=\"line\"><span class=\"keyword\">const</span> args = <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;minimist&#x27;</span>)(rawArgv)</span><br><span class=\"line\"><span class=\"keyword\">const</span> command = args._[<span class=\"number\">0</span>]</span><br><span class=\"line\"></span><br><span class=\"line\">service.run(command, args, rawArgv).catch(<span class=\"function\"><span class=\"params\">err</span> =&gt;</span> &#123;</span><br><span class=\"line\">  error(err)</span><br><span class=\"line\">  process.exit(<span class=\"number\">1</span>)</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<p>这个文件首先是判断了当前node的版本和<code>vue-cli-service</code>要求的版本是否一致，如果版本太低就得升级node版本。</p>\n<p>紧接着就起了个服务，这个服务是位于<code>lib/Service</code>。</p>\n<h3 id=\"Service-js\"><a href=\"#Service-js\" class=\"headerlink\" title=\"Service.js\"></a>Service.js</h3><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">...</span><br><span class=\"line\">loadUserOptions () &#123;</span><br><span class=\"line\">    <span class=\"comment\">// vue.config.js</span></span><br><span class=\"line\">    <span class=\"keyword\">let</span> fileConfig, pkgConfig, resolved, resovledFrom</span><br><span class=\"line\">    <span class=\"keyword\">const</span> configPath = (</span><br><span class=\"line\">      process.env.VUE_CLI_SERVICE_CONFIG_PATH ||</span><br><span class=\"line\">      path.resolve(<span class=\"built_in\">this</span>.context, <span class=\"string\">&#x27;vue.config.js&#x27;</span>)</span><br><span class=\"line\">    )</span><br><span class=\"line\">    ...</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// package.vue</span></span><br><span class=\"line\">    pkgConfig = <span class=\"built_in\">this</span>.pkg.vue</span><br><span class=\"line\">    ...</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (fileConfig) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (pkgConfig) &#123;</span><br><span class=\"line\">        ...</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      resolved = fileConfig</span><br><span class=\"line\">      resovledFrom = <span class=\"string\">&#x27;vue.config.js&#x27;</span></span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (pkgConfig) &#123;</span><br><span class=\"line\">      resolved = pkgConfig</span><br><span class=\"line\">      resovledFrom = <span class=\"string\">&#x27;&quot;vue&quot; field in package.json&#x27;</span></span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      resolved = <span class=\"built_in\">this</span>.inlineOptions || &#123;&#125;</span><br><span class=\"line\">      resovledFrom = <span class=\"string\">&#x27;inline options&#x27;</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    <span class=\"keyword\">return</span> resolved</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">...</span><br></pre></td></tr></table></figure>\n<p>在<code>loadUserOptions</code>这个函数中，你可以看到官方提到的<code>vue.config.js</code>。<br>这个函数主要是加载用户的配置。如果<code>vue.config.js</code>和<code>package.json</code>的vue字段同时存在，会忽略<code>package.json</code>的vue字段配置，而选取<code>vue.config.js</code>的配置。</p>\n<p>这里粗略介绍了何处加载了  vue.confg.js  文件，有兴趣可以继续深究。经过安装CLI、创建项目到整个项目结构介绍，我们可以大致了解了两者的区别。接下来大家一起围观一下<code>CLI 3</code>给我们带来的哪些新特性吧<del>~</del></p>\n<h2 id=\"新特新\"><a href=\"#新特新\" class=\"headerlink\" title=\"新特新\"></a>新特新</h2><h3 id=\"CLI插件的出现\"><a href=\"#CLI插件的出现\" class=\"headerlink\" title=\"CLI插件的出现\"></a>CLI插件的出现</h3><p>据我所知，在<code>CLI 3</code>之前是没有CLI插件这个概念的，人们在开发Vue项目时，若是需要实现功能都是引用npm的相关包。<code>CLI 3</code>的出现，带来了CLI插件这个概念，也带来了统一的命名方式：<code>@vue/cli-plugin-</code>（内建插件）/ <code>vue-cli-plugin-</code>（社区插件）开头。</p>\n<p><img src=\"https://user-images.githubusercontent.com/17926741/98779806-45eaa300-242f-11eb-9452-1145566cbd20.png\" alt=\"CLI 3出现前包名\"></p>\n<p><img src=\"https://user-images.githubusercontent.com/17926741/98779816-46833980-242f-11eb-89ad-743d43889e14.png\" alt=\"CLI插件\"></p>\n<h3 id=\"即刻创建原型\"><a href=\"#即刻创建原型\" class=\"headerlink\" title=\"即刻创建原型\"></a>即刻创建原型</h3><p>有时候你想快速创建一个原型，不需要添加一大堆样板。Vue CLI就提供了一个运行原型的开发服务器。</p>\n<p>要想使用这个开发服务器，前提是安装<code>@vue/cli-service-global</code></p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install -g @vue/cli-service-global</span><br></pre></td></tr></table></figure>\n<p>你可以用IDE创建.vue文件，并添加vue代码。如果你对命令行掌握良好，也能轻松创建。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">echo</span> <span class=\"string\">&#x27;hello world&#x27;</span> &gt; src/views/HelloWorld.vue</span><br></pre></td></tr></table></figure>\n<p>然后将HelloWorld.vue 修改为标准的vue文件结构就行。</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">template</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">div</span>&gt;</span>hello world!<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">template</span>&gt;</span></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>紧接着你就可以运行<code>vue serve src/views/HelloWorld.vue</code> 就能看效果啦~</p>\n<p><img src=\"https://user-images.githubusercontent.com/17926741/98778982-1dae7480-242e-11eb-9923-5b8b51a69878.png\" alt=\"快速原型开发\"></p>\n<h3 id=\"配置时无需Eject\"><a href=\"#配置时无需Eject\" class=\"headerlink\" title=\"配置时无需Eject\"></a>配置时无需Eject</h3><p>如果你曾经是一位React的忠实用户，或许使用过<a href=\"https://github.com/facebookincubator/create-react-app\">create-react-app</a>（react的脚手架），那你对eject的理解可能就很深刻了。可惜小女不才，早期与React只有一面之缘，也就没此机会接触<code>create-react-app</code>。为了理解eject到底是何物，我查看了react的相关文档，终于明白了。<br>在react中，使用CRA（ <code>create-react-app</code>简称）创建完项目，我们可以在package.json看到这里一个script命令。</p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&quot;scripts&quot;: &#123;</span><br><span class=\"line\">  &quot;eject&quot;: &quot;react-scripts eject&quot;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>执行完<code>npm run eject</code>会将封装在CRA里的配置全部<em>反编译</em>到当前项目，换句话就是把之前好不容易藏好了config文件暴露出来了，用户也就获取到了控制权，想怎么改随你。这样<code>react-scripts</code>就以文件的形式存在于项目中，就无法升级啦。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># eject 后项目根目录下会出现 config 文件夹，里面就包含了 webpack 配置</span><br><span class=\"line\">config</span><br><span class=\"line\">├── env.js</span><br><span class=\"line\">├── jest</span><br><span class=\"line\">│   ├── cssTransform.js</span><br><span class=\"line\">│   └── fileTransform.js</span><br><span class=\"line\">├── paths.js</span><br><span class=\"line\">├── polyfills.js</span><br><span class=\"line\">├── webpack.config.dev.js &#x2F;&#x2F; 开发环境配置</span><br><span class=\"line\">├── webpack.config.prod.js &#x2F;&#x2F; 生产环境配置</span><br><span class=\"line\">└── webpackDevServer.config.js</span><br></pre></td></tr></table></figure>\n<p><strong>好在<code>CLI 3</code>并没有像CRA一样，开发者你要是想自己修改配置，也是可以的，我不需要你eject，你想改就去vue.config.js里改吧。</strong><br><img src=\"https://user-images.githubusercontent.com/17926741/98778972-1b4c1a80-242e-11eb-9249-4a803f012815.png\"></p>\n<p>如果你想看看默认的webpack配置，可执行<code>vue inspect</code>查看，默认情况下，会将配置输出到控制台，你也可以将结果指向一个文件，例如：<code>vue inspect &gt; webpack.config.js</code>。</p>\n<h3 id=\"使用图形化界面\"><a href=\"#使用图形化界面\" class=\"headerlink\" title=\"使用图形化界面\"></a>使用图形化界面</h3><p>图形界面化能快速引导用户创建和管理项目，这对于习惯了图形界面化的开发者来说简直就是福音。操作方式很简单，在你安装好了<code>CLI 3</code>的前提下，执行<code>vue ui</code>命令 ，会自动在浏览器打开图形界面。</p>\n<p><img src=\"https://user-images.githubusercontent.com/17926741/98778984-1e470b00-242e-11eb-9d43-2094ec4ed4f3.png\" alt=\"Vue CLI图形界面\"></p>\n<p>创建项目的整个流程跟命令创建项目大同小异。这里介绍下一个<strong>“导入”</strong>功能，正常情况下不是用这个图形界面创建的项目是不会出现在项目列表中，如果你想把已有的项目也放在Vue CLI 图形界面管理，可将项目导入进来。导入项目到底有什么好处呢？这里就厉害了！一个项目导入进来，会按四个部分进行管理项目，分别为插件、依赖、配置和任务</p>\n<h5 id=\"插件\"><a href=\"#插件\" class=\"headerlink\" title=\"插件\"></a>插件</h5><p>在插件这一部分罗列了项目已安装的CLI插件，除此之外，用户还可以随时添加插件，默认推荐给你添加vue-router和vuex。更棒的是还未每个插件提供了官方文档，是不是很贴心~</p>\n<h5 id=\"依赖\"><a href=\"#依赖\" class=\"headerlink\" title=\"依赖\"></a>依赖</h5><p>我们都知道依赖分为开发依赖和运行依赖，在图形界面未出现时，我们要移除不用的依赖还得根据环境进行移除，移除开发依赖执行<code>npm uninstall xx --save-dev</code>，移除运行依赖<code>npm uninstall xx --save</code>。移除之前你可能都要去package.json里查看相关依赖名，很是费劲。还在图形化界面解决了这个问题，轻轻松松你就可以移除不需要得依赖。</p>\n<h5 id=\"配置\"><a href=\"#配置\" class=\"headerlink\" title=\"配置\"></a>配置</h5><p>关于vue.config.js文件的配置，在这也提供了入口。这里它分为基础配置和CSS配置，别觉得少，但这却是最基本、最经常被修改的配置。如果无法满足你根本需求，你也可以打开vue.config.js文件并参考官方配置。除此之外也提供了ESlint的相关配置。</p>\n<h5 id=\"任务\"><a href=\"#任务\" class=\"headerlink\" title=\"任务\"></a>任务</h5><p>笔者觉得，厉害的还是任务这一栏。这一栏目包含了<code>serve</code>、<code>build</code>、<code>lint</code>和<code>inspect</code>。项目的运行情况、数据分析、编译进度、检查webpack配置等。真的很厉害有木有~<br><img src=\"https://user-images.githubusercontent.com/17926741/98778978-1d15de00-242e-11eb-8fe3-bedb153157de.png\" alt=\"所有信息尽收眼底\"></p>\n<p>新特性到此就介绍完毕了。初次写一篇这么长的文章，如有不足，请多见谅。感谢查阅~~<br><img src=\"https://user-images.githubusercontent.com/17926741/98778988-1edfa180-242e-11eb-8bd1-4d078318ac8c.png\"></p>\n<p>参考资料：</p>\n<p><a href=\"https://cli.vuejs.org/zh/guide/\">https://cli.vuejs.org/zh/guide/</a><br><a href=\"https://npmjs.com/package/vue-cli\">https://npmjs.com/package/vue-cli</a><br><a href=\"http://zhaozhiming.github.io/blog/2018/01/08/create-react-app-override-webpack-config/\">http://zhaozhiming.github.io/blog/2018/01/08/create-react-app-override-webpack-config/</a><br><a href=\"https://segmentfault.com/a/1190000012581869#articleHeader5\">https://segmentfault.com/a/1190000012581869#articleHeader5</a><br><a href=\"http://www.css88.com/archives/8405\">http://www.css88.com/archives/8405</a></p>\n","categories":["前端"],"tags":["vue"]},{"title":"about","url":"http://example.com/about/index.html","content":"","categories":[],"tags":[]},{"title":"category","url":"http://example.com/category/index.html","content":"","categories":[],"tags":[]},{"title":"link","url":"http://example.com/link/index.html","content":"","categories":[],"tags":[]},{"title":"search","url":"http://example.com/search/index.html","content":"","categories":[],"tags":[]},{"title":"tag","url":"http://example.com/tag/index.html","content":"","categories":[],"tags":[]}]